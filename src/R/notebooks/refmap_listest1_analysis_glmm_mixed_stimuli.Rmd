---
title: "REFMAP listening test 1 analysis: Regression modelling for annoyance"
output: html_document
date: "2025-02-08"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Setup

Load packages

```{r}
library(conflicted)
library(MASS)
library(lme4)
library(tidyverse)
library(broom)
library(openxlsx)
library(ggeffects)
library(stats)
library(easystats)
library(viridis)
library(flexplot)
library(ggnewscale)
library(patchwork)
# library(emojifont)
# library(microbenchmark)
# set package parameters
theme_set(theme_bw())

lmcontrol <- lme4::lmerControl(optimizer = 'bobyqa',
                               optCtrl = list(maxfun = 1e6))
glmcontrol <- lme4::glmerControl(optimizer = 'bobyqa',
                                 optCtrl = list(maxfun = 1e6))

```

Set parameters

```{r}

# plot colour scheme

mycolourlist = list(c(0, 102, 255), c(0, 204, 153), c(255, 0, 102), c(74, 111, 152), c(251, 164, 49), c(204, 153, 255), c(90, 192, 255), c(80, 245, 233), c(255, 90, 192), c(164, 201, 242), c(255, 254, 139), c(255, 243, 255))
mycolours = matrix()

for (ii in 1:length(mycolourlist)){
  mycolours[ii] = rgb(mycolourlist[[ii]][1]/255,
                      mycolourlist[[ii]][2]/255,
                      mycolourlist[[ii]][3]/255)
}

# toggle to save plots
saveplots = TRUE

if (saveplots){
  # set output plot directory
  choose.files(caption="Just cancel this", filters=matrix(data=c(" ", " "), ncol=2))  # workaround for bug in RTerm choose.dir
  outFigPath <- utils::choose.dir(caption="Select output folder to save plots")
  
  if (!dir.exists(file.path(outFigPath, "svg"))){dir.create(file.path(outFigPath, "svg"))}
  if (!dir.exists(file.path(outFigPath, "pdf"))){dir.create(file.path(outFigPath, "pdf"))}
  
}

# toggle to save data
savedata = TRUE

if (savedata){
  # set output plot directory
  if (saveplots==FALSE){
    choose.files(caption="Just cancel this", filters=matrix(data=c(" ", " "), ncol=2))  # workaround for bug in RTerm choose.dir
  }
  outDataPath <- utils::choose.dir(caption="Select output folder to save data")
}

set.seed(84984894)


```

# Functions

## Predicting from model objects with new data (such as mean values)

```{r}

predictNew <- function(model, response, newData, fixVars=NULL){
  
  # check response variable is the same length as the newData variables
  if (length(response) != nrow(newData)){
    stop("Response variable must be the same length as the new data")
  }

  # get predictor variables from model
  pred <- insight::find_predictors(model, flatten = TRUE)

  # if fixVars is not null
  if (!is.null(fixVars)){
    # check if fixVars is a list or named vector and convert to dataframe if necessary
    if (is.list(fixVars) | is.vector(fixVars)){
      fixVars <- t(as.data.frame(fixVars))
      # remove redundant rowname
      rownames(fixVars) <- NULL
    }
    
    # remove fixed variables from predictors
    pred <- pred[!pred %in% colnames(fixVars)]
  
  }
  
  # assign columns from newData to dat
  dat <- newData[pred]
  
  # if fixVars is not null
  if (!is.null(fixVars)){
    # add fixed variable columns
    dat <- cbind(dat, fixVars)
  }
  
  if (class(model) == "glmgee"){
    # make predictions with new data
    predictions <- predict(model, newdata=dat, type='response', varest='bias-corrected')
  } else {
    # make predictions with new data
    predictions <- predict(model, newdata=dat, type='response')
  }
  # bind predictions to dat
  predictDat <- cbind(dat, response=response, fit=predictions)

  # include rownames
  rownames(predictDat) <- newData$X
  
  # return output
  return(predictDat)
}

```

## (Herron) estimated percentage correct predictions (ePCP) for GLMM models

```{r}

glmmPCP <- function(...){
   if (length(list(...)) == 1){
      
      model_objects <- insight::ellipsis_info(..., ..., only_models = TRUE)
      model_objects <- model_objects[1]

  } else{

      model_objects <- insight::ellipsis_info(..., only_models = TRUE)
  
  }
  
  # ensure proper object names
  dot_names <- sapply(match.call(expand.dots = FALSE)[["..."]], as.character)
  check_object_names <- insight::compact_character(names(model_objects))
  if ((is.null(check_object_names) ||
    # or if length of names doesn't match number of models
    length(check_object_names) != length(model_objects) ||
    # or if names are "..1", "..2" pattern
    all(grepl("\\.\\.\\d", check_object_names))) &&
    # and length of dot-names must match length of objects
    length(model_objects) == length(dot_names)) {
    names(model_objects) <- dot_names
  }
  
  object_names <- names(model_objects)
  
  m <- mapply(function(.x, .y) {
    y_full <- .x@resp$y

    n_full <- suppressWarnings(insight::n_obs(.x))

    pr_full <- stats::predict(.x, type = "response")
    
    pcp_full <- (sum(1 - pr_full[y_full == 0]) + sum(pr_full[y_full == 1])) / n_full
    
    dat <- data.frame(ePCP=pcp_full)
    model_name <- gsub("\"", "", insight::safe_deparse(.y), fixed = TRUE)
    perf_df <- data.frame(Name = model_name, Model = class(.x)[1], dat, stringsAsFactors = FALSE)

  }, model_objects, object_names, SIMPLIFY = FALSE)
  
  dfs <- Reduce(function(x, y) merge(x, y, all = TRUE, sort = FALSE), m)

  return(dfs)

}


```

## Assign nearest numbers from list

```{r}

numberSnap <- function(numbersIn, numberList, rangeVal){
  
  numberList<-sort(numberList)          # need them sorted
  rangeVal <- rangeVal*1.000001                             # avoid rounding issues
  nearest <- findInterval(numbersIn, numberList - rangeVal) # index of nearest
  nearest <- c(-Inf, numberList)[nearest + 1]  # value of nearest
  diff <- numbersIn - nearest                           # compute errors
  snap <- diff <= rangeVal                               # only snap near numbers
  
  numbersOut <- numbersIn
  numbersOut[snap] <- nearest[snap]                      # snap values to nearest
  
  return(numbersOut)
  
}


```

## Rescale ggplot tick marks for variables

```{r}

rescaleTicks <- function(dataVar, dataVarScl, sep=3, ax='x'){
  
  if (ax == 'x'){
    outAx <- scale_x_continuous(breaks=seq(floor(min(dataVar)),
                                           ceiling(max(dataVar)),
                                           by=sep) -
                                  (max(dataVar) - max(dataVarScl)),
                                labels=seq(floor(min(dataVar)),
                                           ceiling(max(dataVar)),
                                           by=sep))

  } else if (ax == 'y'){
    outAx <- scale_y_continuous(breaks=seq(floor(min(dataVar)),
                                           ceiling(max(dataVar)),
                                           by=sep) -
                                  (max(dataVar) - max(dataVarScl)),
                                labels=seq(floor(min(dataVar)),
                                           ceiling(max(dataVar)),
                                           by=sep))
  } else {
    stop("Invalid axis argument")
  }
 
  return(outAx) 
}


```

# Import data and wrangle

## Parts A & B combined

```{r}

subjDataPath <- utils::choose.files(caption=r"(Select refmap_listest1_testdata_BySubj.csv from 03 Experiment\Experiment 1\Analysis\PostProcess)",
                                     filters=matrix(data=c("refmap_listest1_testdata_BySubj.csv", "refmap_listest1_testdata_BySubj.csv"), ncol=2))

subjData <- read.csv(subjDataPath, header=TRUE)

stimDataPath <- utils::choose.files(caption=r"(Select refmap_listest1_testdata_ByStim.csv from 03 Experiment\Experiment 1\Analysis\PostProcess)",
                                     filters=matrix(data=c("refmap_listest1_testdata_ByStim.csv", "refmap_listest1_testdata_ByStim.csv"), ncol=2))

stimData <- read.csv(stimDataPath, header=TRUE)

```

```{r}
# definition of ordinal variable levels
UASLAeqCatsA <- c("No UAS", "42", "48", "54", "60")
SNRCatsA <- c("No UAS", "-16", "-10", "-4", "2", "8")
UASOpCatsA <- c("No UAS", "Flyover", "Landing", "Takeoff")
UASTypeCatsA <- c("No UAS", "H520", "M300", "T150")

# encode factors
subjData$ID. <- factor(subjData$ID.)
subjData$UASLAeq <- factor(subjData$UASLAeq, levels=UASLAeqCatsA, order=TRUE)
subjData$SNRlevel <- factor(subjData$SNRlevel, levels=SNRCatsA, order=TRUE)
subjData$UASOperation <- factor(subjData$UASOperation, levels=UASOpCatsA)
subjData$UASType <- factor(subjData$UASType, levels=UASTypeCatsA)
subjData$AmbientEnv <- factor(subjData$AmbientEnv, levels=c("Park", "Street"))
subjData$AAM_attitude <- factor(subjData$AAM_attitude)
subjData$Home_Area <- factor(subjData$Home_Area)
subjData$Area_soundscape <- factor(subjData$Area_soundscape)
subjData$NationGeo <- factor(subjData$NationGeo)

# recode AAM_attitude to 3 groups
subjData <- subjData |> dplyr::mutate(AAM_attitude3 = case_match(AAM_attitude,
                                                                    "Supportive" ~ "Supportive",
                                                                    c("Ambivalent",
                                                                      "Concerned") ~ "Ambiv_Concern",
                                                                      "Neutral" ~ "Neutral"))
subjData$AAM_attitude3 <- factor(subjData$AAM_attitude3)

# recode AAM_attitude to 2 groups
subjData <- subjData |> dplyr::mutate(AAM_attitude2 = case_match(AAM_attitude,
                                                                    "Supportive" ~ "Supportive",
                                                                    c("Ambivalent",
                                                                      "Concerned",
                                                                      "Neutral") ~ "Ambiv_Concern_Neutral"))
subjData$AAM_attitude2 <- factor(subjData$AAM_attitude2)

# recode AAM_attitude to 2 other groups
subjData <- subjData |> dplyr::mutate(AAM_attitude2_2 = case_match(AAM_attitude,
                                                                    c("Supportive",
                                                                      "Ambivalent") ~ "Support_Ambiv",
                                                                    c("Concerned",
                                                                      "Neutral") ~ "Concern_Neutral"))

subjData$AAM_attitude2_2 <- factor(subjData$AAM_attitude2_2)

# recode NationGeo to 4 groups
subjData <- subjData |> dplyr::mutate(NationGeo4 = case_match(NationGeo,
                                                               "UK" ~ "UK",
                                                               c("Africa",
                                                                 "SouthAsia") ~ "Africa_SAsia",
                                                               c("Australasia",
                                                                 "EastAsia",
                                                                 "Europe",
                                                                 "MidEast",
                                                                 "SouthAmerica") ~ "Other",
                                                               "" ~ "Unspecified"))
subjData$NationGeo4 <- factor(subjData$NationGeo4)

# recode NationGeo to 3 groups
subjData <- subjData |> dplyr::mutate(NationGeo3 = case_match(NationGeo,
                                                                 "UK" ~ "UK",
                                                                 c("Africa",
                                                                   "SouthAsia") ~ "Africa_SAsia",
                                                                 c("Australasia",
                                                                   "EastAsia",
                                                                   "Europe",
                                                                   "MidEast",
                                                                   "SouthAmerica",
                                                                   "") ~ "Other"))
subjData$NationGeo3 <- factor(subjData$NationGeo3)

# recode NationGeo to 2 groups
subjData <- subjData |> dplyr::mutate(NationGeo2 = case_match(NationGeo,
                                                                 "UK" ~ "UK",
                                                                 c("Africa",
                                                                   "SouthAsia",
                                                                   "Australasia",
                                                                   "EastAsia",
                                                                   "Europe",
                                                                   "MidEast",
                                                                   "SouthAmerica",
                                                                   "") ~ "Other"))
subjData$NationGeo2 <- factor(subjData$NationGeo2)


subjData$NationGeo3 <- factor(subjData$NationGeo3)

# recode Area of residence to 2 groups
subjData <- subjData |> dplyr::mutate(Home_Area2 = case_match(Home_Area,
                                                         "Urban" ~ "Urban",
                                                         c("Suburban",
                                                           "Rural") ~ "Suburban_Rural"))
subjData$Home_Area2 <- factor(subjData$Home_Area2)


# recode Area soundscape to 2 groups
subjData <- subjData |> dplyr::mutate(Area_soundscape2 = case_match(Area_soundscape,
                                                                       c("Calm",
                                                                         "Monotonous") ~ "Uneventful",
                                                                       c("Chaotic",
                                                                         "Vibrant") ~ "Eventful"))

subjData$Area_soundscape2 <- factor(subjData$Area_soundscape2)

# create column with Part B TrialNumbers continuing from Part A
subjData$TrialNumberCnt <- subjData$TrialNumber
subjData$TrialNumberCnt[subjData$SessionPart == "B"] <- subjData$TrialNumberCnt[subjData$SessionPart == "B"] + 
                                                              max(subjData$TrialNumber[subjData$SessionPart=="A"])

# ensure that participant ID. 17 TrialNumberCnt starts from 61 (as they had done 60 in Part A)
subjData$TrialNumberCnt[subjData$ID. == 17] <- subjData$TrialNumberCnt[subjData$ID. == 17] - 20

# rescale trial number variables separately for each session part
subjData <- rbind(subjData[subjData$SessionPart == "A", ] |> dplyr::mutate(TrialNumberScl = datawizard::standardise(TrialNumber, scale=TRUE)),
                    subjData[subjData$SessionPart == "B", ] |> dplyr::mutate(TrialNumberScl = datawizard::standardise(TrialNumber, scale=TRUE)))
subjData <- subjData |> dplyr::mutate(TrialNumberCntScl = datawizard::standardise(TrialNumberCnt, scale=TRUE))

# relocate new columns
subjData <- subjData |> dplyr::relocate(TrialNumberCnt, TrialNumberScl,
                                        TrialNumberCntScl, .after=TrialNumber)

# rescale variables
subjData <- subjData |> dplyr::mutate(UASLAeqMaxLRScl = datawizard::standardise(UASLAeqMaxLR, scale=FALSE))
subjData <- subjData |> dplyr::mutate(UASLAEMaxLRScl = datawizard::standardise(UASLAEMaxLR, scale=FALSE))
subjData <- subjData |> dplyr::mutate(UASEPNLMaxLRScl = datawizard::standardise(UASEPNLMaxLR, scale=FALSE))
subjData <- subjData |> dplyr::mutate(LAELAF50diffScl = datawizard::standardise(LAELAF50diff, scale=FALSE))
subjData <- subjData |> dplyr::mutate(LAELAeqdiffScl = datawizard::standardise(LAELAeqdiff, scale=FALSE))
subjData <- subjData |> dplyr::mutate(EPNLLAeqdiffScl = datawizard::standardise(EPNLLAeqdiff, scale=FALSE))
subjData <- subjData |> dplyr::mutate(UASDisc0p5LAEMaxLRScl = datawizard::standardise(UASDisc0p5LAEMaxLR, scale=FALSE))
subjData <- subjData |> dplyr::mutate(UASDisc0p5PAEMaxLR = 2e-5*10^(UASDisc0p5LAEMaxLR/20))
subjData <- subjData |> dplyr::mutate(UASLoudECMAPowAvgBinScl = datawizard::standardise(UASLoudECMAPowAvgBin, scale=FALSE))
subjData <- subjData |> dplyr::mutate(IntermitRatioC2MaxLRScl = IntermitRatioC2MaxLR/100)
subjData <- subjData |> dplyr::mutate(IntermitRatioC3MaxLRScl = IntermitRatioC3MaxLR/100)
subjData <- subjData |> dplyr::mutate(IntermitRatioC5MaxLRScl = IntermitRatioC5MaxLR/100)
subjData <- subjData |> dplyr::mutate(AmbLAeqMaxLRScl = datawizard::standardise(AmbLAeqMaxLR, scale=FALSE))
subjData <- subjData |> dplyr::mutate(AmbLAF50ExMaxLRScl = datawizard::standardise(AmbLAF50ExMaxLR, scale=FALSE))


stimData <- stimData |> dplyr::mutate(UASLAeqMaxLRScl = datawizard::standardise(UASLAeqMaxLR, scale=FALSE))
stimData <- stimData |> dplyr::mutate(UASLAEMaxLRScl = datawizard::standardise(UASLAEMaxLR, scale=FALSE))
stimData <- stimData |> dplyr::mutate(UASEPNLMaxLRScl = datawizard::standardise(UASEPNLMaxLR, scale=FALSE))
stimData <- stimData |> dplyr::mutate(LAELAF50diffScl = datawizard::standardise(LAELAF50diff, scale=FALSE))
stimData <- stimData |> dplyr::mutate(LAELAeqdiffScl = datawizard::standardise(LAELAeqdiff, scale=FALSE))
stimData <- stimData |> dplyr::mutate(EPNLLAeqdiffScl = datawizard::standardise(EPNLLAeqdiff, scale=FALSE))
stimData <- stimData |> dplyr::mutate(UASDisc0p5LAEMaxLRScl = datawizard::standardise(UASDisc0p5LAEMaxLR, scale=FALSE))
stimData <- stimData |> dplyr::mutate(UASDisc0p5PAEMaxLR = 2e-5*10^(UASDisc0p5LAEMaxLR/20))
stimData <- stimData |> dplyr::mutate(UASLoudECMAPowAvgBinScl = datawizard::standardise(UASLoudECMAPowAvgBin, scale=FALSE))
stimData <- stimData |> dplyr::mutate(IntermitRatioC2MaxLRScl = IntermitRatioC2MaxLR/100)
stimData <- stimData |> dplyr::mutate(IntermitRatioC3MaxLRScl = IntermitRatioC3MaxLR/100)
stimData <- stimData |> dplyr::mutate(IntermitRatioC5MaxLRScl = IntermitRatioC5MaxLR/100)
stimData <- stimData |> dplyr::mutate(AmbLAeqMaxLRScl = datawizard::standardise(AmbLAeqMaxLR, scale=FALSE))
stimData <- stimData |> dplyr::mutate(AmbLAF50ExMaxLRScl = datawizard::standardise(AmbLAF50ExMaxLR, scale=FALSE))


# convert detectability dB to log variables
subjData <- subjData |> dplyr::mutate(Detect0p1IntMaxLRLog = Detect0p1dBIntMaxLR/10)
subjData <- subjData |> dplyr::mutate(Detect0p5IntMaxLRLog = Detect0p5dBIntMaxLR/10)
subjData <- subjData |> dplyr::mutate(Detect0p1MaxMaxLRLog = Detect0p1dBMaxMaxLR/10)
subjData <- subjData |> dplyr::mutate(Detect0p5MaxMaxLRLog = Detect0p5dBMaxMaxLR/10)
subjData <- subjData |> dplyr::mutate(Detect0p1IntMaxLRLogScl = datawizard::standardise(Detect0p1IntMaxLRLog, scale=FALSE))
subjData <- subjData |> dplyr::mutate(Detect0p5IntMaxLRLogScl = datawizard::standardise(Detect0p5IntMaxLRLog, scale=FALSE))
subjData <- subjData |> dplyr::mutate(Detect0p1MaxMaxLRLogScl = datawizard::standardise(Detect0p1MaxMaxLRLog, scale=FALSE))
subjData <- subjData |> dplyr::mutate(Detect0p5MaxMaxLRLogScl = datawizard::standardise(Detect0p5MaxMaxLRLog, scale=FALSE))

stimData <- stimData |> dplyr::mutate(Detect0p1IntMaxLRLog = Detect0p1dBIntMaxLR/10)
stimData <- stimData |> dplyr::mutate(Detect0p5IntMaxLRLog = Detect0p5dBIntMaxLR/10)
stimData <- stimData |> dplyr::mutate(Detect0p1MaxMaxLRLog = Detect0p1dBMaxMaxLR/10)
stimData <- stimData |> dplyr::mutate(Detect0p5MaxMaxLRLog = Detect0p5dBMaxMaxLR/10)
stimData <- stimData |> dplyr::mutate(Detect0p1IntMaxLRLogScl = datawizard::standardise(Detect0p1IntMaxLRLog, scale=FALSE))
stimData <- stimData |> dplyr::mutate(Detect0p5IntMaxLRLogScl = datawizard::standardise(Detect0p5IntMaxLRLog, scale=FALSE))
stimData <- stimData |> dplyr::mutate(Detect0p1MaxMaxLRLogScl = datawizard::standardise(Detect0p1MaxMaxLRLog, scale=FALSE))
stimData <- stimData |> dplyr::mutate(Detect0p5MaxMaxLRLogScl = datawizard::standardise(Detect0p5MaxMaxLRLog, scale=FALSE))

# Log other variables
subjData$PartLoudMGLT05ExLog <- log(subjData$PartLoudMGLT05Ex)
subjData$PartLoudMGST05ExLog <- log(subjData$PartLoudMGST05Ex)
subjData$PartLoudMGLTPowAvgLog <- log(subjData$PartLoudMGLTPowAvg)
subjData$PartLoudMGSTPowAvgLog <- log(subjData$PartLoudMGSTPowAvg)

stimData$PartLoudMGLT05ExLog <- log(stimData$PartLoudMGLT05Ex)
stimData$PartLoudMGST05ExLog <- log(stimData$PartLoudMGST05Ex)
stimData$PartLoudMGLTPowAvgLog <- log(stimData$PartLoudMGLTPowAvg)
stimData$PartLoudMGSTPowAvgLog <- log(stimData$PartLoudMGSTPowAvg)

# reorder by participant ID and trial number
subjData <- subjData[with(subjData, order(ID., TrialNumberCnt)), ]

# omit ambient-only stimuli
subjDataNoAmb <- subjData |> dplyr::filter(UASLAeq != "No UAS")
stimDataNoAmb <- stimData |> dplyr::filter(UASLAeq != "No UAS")

# re-encode factors omitting ambient-only stimuli
subjDataNoAmb$SNRlevel <- factor(subjDataNoAmb$SNRlevel, levels=SNRCatsA[2:length(SNRCatsA)], order=TRUE)
subjDataNoAmb$UASOperation <- factor(subjDataNoAmb$UASOperation, levels=UASOpCatsA[2: length(UASOpCatsA)])
subjDataNoAmb$UASType <- factor(subjDataNoAmb$UASType, levels=UASTypeCatsA[2:length(UASTypeCatsA)])
stimDataNoAmb$SNRlevel <- factor(stimDataNoAmb$SNRlevel, levels=SNRCatsA[2:length(SNRCatsA)], order=TRUE)
stimDataNoAmb$UASOperation <- factor(stimDataNoAmb$UASOperation, levels=UASOpCatsA[2: length(UASOpCatsA)])
stimDataNoAmb$UASType <- factor(stimDataNoAmb$UASType, levels=UASTypeCatsA[2:length(UASTypeCatsA)])

```

Parts A & B combined analysis

# Change in mean annoyance rating

## Categorical models

### Fit a baseline model

```{r}
# baseline model (no predictors, only clustered intercept)
mABBL <- lme4::lmer(dAnnoyance ~ TrialNumberCntScl + 1 + (1 | ID.) + (1 | StimID),
                    data=subjDataNoAmb, control=lmcontrol, REML=FALSE)

# check the intraclass correlation coefficient and pseudo-Rsquared
performance::icc(mABBL)
performance::r2(mABBL)

params <- parameters::model_parameters(mABBL)

```

#### Plot baseline model

```{r, fig.width=7, fig.height=5}
# plot the baseline

pred <- ggeffects::predict_response(mABBL, terms=c("ID."), margin='empirical')
colnames(pred)[which(names(pred) == "x")] <- "ID."

pred <- pred[order(as.numeric(as.character(pred$ID.))), ]
pred$ID. <- factor(pred$ID., levels=paste(sort(as.integer(levels(pred$ID.)))))

df <- data.frame(ID=pred$ID., dAnnoyance=pred$predicted,
                   dAnnoyMean=rep(params$Coefficient[1], length(pred$ID.)),
                   dAnnoyCILow=rep(params$CI_low[1], length(pred$ID.)),
                   dAnnoyCIHigh=rep(params$CI_high[1], length(pred$ID.)))

ggplot(df) +
  geom_ribbon(mapping=aes(ID, ymin=dAnnoyCILow, ymax=dAnnoyCIHigh),
                          alpha=0.1, colour = NA, group=1, fill=mycolours[4]) +
  geom_line(mapping=aes(ID, dAnnoyMean), group=1, color=mycolours[4]) +
  geom_point(data=pred, mapping=aes(x=ID., y=predicted), color=mycolours[4], size=3, alpha=0.5) +
  scale_y_continuous(n.breaks=10, limits=c(-4, 7)) +
  theme(text = element_text(family = "serif"),
        panel.grid=element_line(color = rgb(235, 235, 235, 90, maxColorValue = 255)),
        axis.text.x  = element_text(size=8),
        axis.text.y  = element_text(size=14),
        axis.title.x  = element_text(size=16),
        axis.title.y  = element_text(size=16)) +
labs(x="Participant", y="Mean change in annoyance rating \n(rel. to baseline)")

```

```{r, fig.width=7, fig.height=5}

```


